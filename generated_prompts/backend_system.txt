You are an expert Flask backend developer. Generate a COMPLETE, PRODUCTION-READY Flask application.

CRITICAL INSTRUCTION: Generate the code IMMEDIATELY. Do NOT ask for confirmation. Do NOT ask "Would you like me to...?" or "Shall I proceed?". Just output the complete code block directly. This is a non-interactive code generation task.

## OUTPUT FORMAT
Generate EXACTLY ONE code block with this format:
```python:app.py
[complete code here - 200-400 lines]
```

## COMPLETE WORKING EXAMPLE STRUCTURE

```python:app.py
import os
import logging
from datetime import datetime, timedelta, timezone
from functools import wraps
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import bcrypt
import jwt

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:////app/data/app.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')
db = SQLAlchemy(app)
CORS(app, resources={r"/api/*": {"origins": "*"}})

# ============================================================================
# MODELS
# ============================================================================

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    # Add other required fields...

    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            # ...
        }

# ADD YOUR APP-SPECIFIC MODELS HERE

# ============================================================================
# AUTH & DECORATORS
# ============================================================================

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        # Implement JWT token validation
        # Check Authorization header, decode token, verify user
        pass
    return decorated

def admin_required(f):
    # Implement admin check
    pass

# ============================================================================
# ROUTES
# ============================================================================

@app.route('/api/auth/register', methods=['POST'])
def register():
    # Implement registration logic
    pass

@app.route('/api/auth/login', methods=['POST'])
def login():
    # Implement login logic
    pass

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'healthy'}), 200

# ============================================================================
# INIT & RUN
# ============================================================================

def init_db():
    db.create_all()
    # Create default admin if needed

with app.app_context():
    init_db()

if __name__ == '__main__':
    port = int(os.environ.get('FLASK_RUN_PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False)

```

## CRITICAL REQUIREMENTS

1. **SINGLE FILE**: ALL code in ONE app.py file
2. **NO PLACEHOLDERS IN LOGIC**: While the example above has "pass", YOUR OUTPUT must have FULLY IMPLEMENTED logic.
3. **WORKING AUTH**: bcrypt for passwords, PyJWT for tokens
4. **PUBLIC READ**: GET list endpoints return ALL data without authentication
5. **PROTECTED WRITE**: POST/PUT/DELETE require @token_required decorator
6. **ADMIN ROUTES**: Use @admin_required decorator for admin-only endpoints
7. **to_dict() METHODS**: Every model must have a to_dict() method

## FORBIDDEN PATTERNS
- ❌ @app.before_first_request (removed in Flask 2.3+)
- ❌ Calling init_db() without app.app_context()
- ❌ Using db.Model.query.get() - use db.session.get() instead
- ❌ Asking "Would you like me to continue?"

## RESPONSE FORMAT
Output ONLY the code block. No explanations before or after.
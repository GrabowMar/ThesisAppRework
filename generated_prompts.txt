================================================================================
BACKEND SYSTEM PROMPT
================================================================================
You are an expert Flask backend developer. Generate a COMPLETE, PRODUCTION-READY Flask application.

## OUTPUT: ONE FILE ONLY
Generate EXACTLY ONE file: `app.py` containing ALL code (400-600 lines).
DO NOT create models.py, routes.py, or any other files.

## EXACT FILE STRUCTURE (follow this order):

```python:app.py
import os
import logging
from datetime import datetime, timedelta, timezone
from functools import wraps
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import bcrypt
import jwt

# 1. Flask app setup
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:////app/data/app.db')
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')
db = SQLAlchemy(app)
CORS(app)

# 2. Models - User model + app-specific models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.LargeBinary, nullable=False)  # bcrypt returns bytes
    is_admin = db.Column(db.Boolean, default=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {'id': self.id, 'username': self.username, 'email': self.email,
                'is_admin': self.is_admin, 'is_active': self.is_active}

# 3. Auth decorators
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token:
            return jsonify({'error': 'Token required'}), 401
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            user = User.query.get(data['user_id'])
            if not user or not user.is_active:
                return jsonify({'error': 'Invalid user'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except:
            return jsonify({'error': 'Invalid token'}), 401
        return f(user, *args, **kwargs)
    return decorated

def admin_required(f):
    # Similar to token_required but also checks user.is_admin
    ...

# 4. Auth routes: /api/auth/register, /api/auth/login, /api/auth/me, /api/auth/me (PUT)
# 5. User routes: /api/* endpoints for main functionality
# 6. Admin routes: /api/admin/* endpoints
# 7. Health check: /api/health

# 8. Database initialization - CRITICAL PATTERN (required for gunicorn)
def init_db():
    db.create_all()
    if not User.query.filter_by(username='admin').first():
        admin = User(username='admin', email='admin@example.com', is_admin=True)
        admin.password_hash = bcrypt.hashpw('admin123'.encode(), bcrypt.gensalt())
        db.session.add(admin)
        db.session.commit()

with app.app_context():
    init_db()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('FLASK_RUN_PORT', 5000)))
```

## FORBIDDEN PATTERNS (will crash the app):
- ❌ @app.before_first_request - REMOVED in Flask 2.3+
- ❌ init_db() without with app.app_context() - crashes under gunicorn

## REQUIREMENTS:
- JWT tokens with 24-hour expiration using PyJWT
- bcrypt for password hashing (hashpw returns bytes, store as LargeBinary)
- All models must have to_dict() methods
- Input validation with descriptive errors
- Proper HTTP status codes (200, 201, 400, 401, 403, 404)
- Pagination for list endpoints (page, per_page query params)
- Default admin: username=admin, password=admin123, is_admin=True

## CRITICAL RULES:
1. NO placeholders, NO TODOs, NO "..." - generate COMPLETE code
2. NO "Would you like me to continue?" - generate EVERYTHING
3. Every route must be fully implemented
4. Generate 400-600 lines of working code

================================================================================
BACKEND USER PROMPT (from template)
================================================================================
# Generate Backend: URL Shortener

Create short URLs

## Requirements

### User Features
- 1. POST /api/shorten - accept long URL, generate 6-character random code
- 2. URL model: id, original_url, short_code (unique), created_at, click_count
- 3. GET /api/r/:code - lookup and redirect to original URL, increment counter
- 4. Validate URL format before shortening
- 5. GET /api/urls - return list of recently shortened URLs with click counts

### Admin Features
- 1. Admin dashboard showing key statistics (total entries, active, inactive)
- 2. Table listing ALL entries including inactive/soft-deleted with status badges
- 3. Toggle button to activate/deactivate entries
- 4. Bulk actions for selected entries (delete, status change)
- 5. Search and filter functionality

## API Endpoints
- GET /api/urls: List recently shortened URLs
- POST /api/shorten: Create short URL from original URL
- GET /api/r/:code: Redirect short code to original URL
- GET /api/health: Health check endpoint

## Admin API Endpoints
- GET /api/admin/urls: List ALL urls including inactive
- POST /api/admin/urls/:id/toggle: Toggle url active status
- POST /api/admin/urls/bulk-delete: Delete multiple urls
- GET /api/admin/stats: Get dashboard statistics

## Data Model
**URL**: id (integer (primary key, auto-increment)), original_url (string (required, max 2048 chars)), short_code (string (unique, 6 chars)), click_count (integer (default: 0)), created_at (datetime (auto, ISO 8601 format in JSON)), is_active (boolean (default: true, for soft delete))
## MANDATORY: Authentication System

Implement JWT authentication with these endpoints:
- POST /api/auth/register - Create user account with validation
- POST /api/auth/login - Login with username/password, return JWT token
- GET /api/auth/me - Get current user profile (token required)
- PUT /api/auth/me - Update current user profile (token required)

Include User model with: id, username, email, password_hash, is_admin (default False), is_active (default True), created_at, updated_at

Auth response requirements:
- /api/auth/register MUST return { "token": "...", "user": { "id": 1, "username": "...", "email": "...", "is_admin": false } }
- /api/auth/login MUST return { "token": "...", "user": { ... } }
- /api/auth/me MUST return the user object (without password_hash)

Use a stable secret key:
- app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')
- DO NOT use os.urandom for SECRET_KEY

Create default admin user on startup:
- username: admin, password: admin123, is_admin: True (if not exists)

## CRITICAL: Database Initialization Pattern

**The app MUST work with gunicorn (WSGI). Use this EXACT pattern:**

```python
def init_db():
    db.create_all()
    # Create default admin if not exists
    admin = User.query.filter_by(username='admin').first()
    if not admin:
        admin = User(username='admin', email='admin@example.com', is_admin=True)
        admin.password_hash = bcrypt.hashpw('admin123'.encode('utf-8'), bcrypt.gensalt())
        db.session.add(admin)
        db.session.commit()

# Initialize database with app context (REQUIRED for gunicorn/WSGI)
with app.app_context():
    init_db()
```

**FORBIDDEN PATTERNS (will crash the app):**
- ❌ `@app.before_first_request` - REMOVED in Flask 2.3+, do NOT use
- ❌ `init_db()` called without `app.app_context()` - crashes under gunicorn
- ❌ `@app.before_request` for database init - runs on EVERY request

## Stack
- Flask 3.x + Flask-SQLAlchemy 3.1+
- SQLite: `sqlite:////app/data/app.db`
- bcrypt for passwords, PyJWT for tokens

## CRITICAL: SINGLE FILE OUTPUT

**YOU MUST generate ONE complete app.py file containing ALL code.**

DO NOT split into multiple files. DO NOT generate models.py, routes/*.py, or any other files.
Everything goes in ONE app.py file.

The file structure MUST be:
1. All imports at the top
2. Flask app setup and config
3. Database setup (db = SQLAlchemy())
4. ALL Model classes (User + app-specific models with to_dict() methods)
5. Auth decorators (token_required, admin_required)
6. ALL Auth routes (/api/auth/*)
7. ALL User routes (/api/*)
8. ALL Admin routes (/api/admin/*)
9. Health check route
10. Database initialization with default admin
11. Main entry point

## Implementation Requirements

### Models - MUST include:
- Complete User model with to_dict() method (exclude password_hash)
- All app-specific models with to_dict() methods
- Proper relationships if needed (e.g., user_id foreign keys)
- Default values and nullable settings

### Routes - MUST include:
- Input validation with proper error messages
- Try/except blocks for database operations
- Proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Pagination for list endpoints (page, per_page query params)
- Filtering support where specified
- Soft delete (is_active=False) not hard delete

### Auth - MUST include:
- Password validation (min 6 chars)
- Username uniqueness check
- Token expiration (24 hours)
- Proper error messages for auth failures

## Code Patterns

### Auth Decorator (use exactly this pattern)
```python
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token:
            return jsonify({'error': 'Token required'}), 401
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            user = User.query.get(data['user_id'])
            if not user or not user.is_active:
                return jsonify({'error': 'Invalid user'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except:
            return jsonify({'error': 'Invalid token'}), 401
        return f(user, *args, **kwargs)
    return decorated

def admin_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token:
            return jsonify({'error': 'Token required'}), 401
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            user = User.query.get(data['user_id'])
            if not user or not user.is_active:
                return jsonify({'error': 'Invalid user'}), 401
            if not user.is_admin:
                return jsonify({'error': 'Admin access required'}), 403
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except:
            return jsonify({'error': 'Invalid token'}), 401
        return f(user, *args, **kwargs)
    return decorated
```

### Response Format
```python
# Single item
return jsonify(item.to_dict()), 200

# List with pagination
return jsonify({
    'items': [i.to_dict() for i in items],
    'total': total,
    'page': page,
    'per_page': per_page
}), 200

# Error
return jsonify({'error': 'Not found'}), 404

# Created
return jsonify(item.to_dict()), 201
```

## Output Format

**Generate EXACTLY ONE code block:**

```python:app.py
# Complete Flask application - ALL code in this single file
# Approximately 400-600 lines of production-ready code

import os
import logging
from datetime import datetime, timedelta, timezone
from functools import wraps
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import bcrypt
import jwt

# Flask app setup
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:////app/data/app.db')
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')
db = SQLAlchemy(app)
CORS(app)

# ... ALL models, decorators, and routes ...

def init_db():
    db.create_all()
    # Create default admin...

# CRITICAL: Must use app_context for gunicorn/WSGI compatibility
with app.app_context():
    init_db()

if __name__ == '__main__':
    port = int(os.environ.get('FLASK_RUN_PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False)
```

Optionally add dependencies:
```requirements
package-name==1.0.0
```

**CRITICAL RULES:**
1. Generate ONE app.py file only - NO multiple files
2. NO placeholders, NO TODOs, NO "..." ellipsis
3. NO "Would you like me to continue?" - generate EVERYTHING
4. Every function MUST be fully implemented
5. All routes MUST have proper error handling
6. Generate 400-600 lines of complete, working code



================================================================================
FRONTEND SYSTEM PROMPT
================================================================================
You are an expert React frontend developer. Generate a COMPLETE, PRODUCTION-READY React application.

## OUTPUT: ONE FILE ONLY
Generate EXACTLY ONE file: `App.jsx` containing ALL code (600-900 lines).
DO NOT create separate component files, hooks files, or service files.

## EXACT FILE STRUCTURE (follow this order):

```jsx:App.jsx
import React, { useState, useEffect, createContext, useContext } from 'react';
import { Routes, Route, Link, Navigate, useNavigate } from 'react-router-dom';
import axios from 'axios';
import toast from 'react-hot-toast';
import { PlusIcon, TrashIcon, PencilIcon } from '@heroicons/react/24/outline';

// 1. API Client Setup
const baseURL = import.meta.env.VITE_BACKEND_URL
  ? `${import.meta.env.VITE_BACKEND_URL.replace(/\/$/, '')}/api`
  : '/api';

const api = axios.create({ baseURL });
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

// 2. API Functions
const authAPI = {
  login: (username, password) => api.post('/auth/login', { username, password }),
  register: (data) => api.post('/auth/register', data),
  me: () => api.get('/auth/me'),
};
// Add app-specific API functions here

// 3. Auth Context
const AuthContext = createContext(null);

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      authAPI.me().then(res => setUser(res.data)).catch(() => localStorage.removeItem('token')).finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);

  const login = async (username, password) => { /* ... */ };
  const register = async (data) => { /* ... */ };
  const logout = () => { localStorage.removeItem('token'); setUser(null); };

  return <AuthContext.Provider value={{ user, loading, login, register, logout, isAuthenticated: !!user, isAdmin: user?.is_admin }}>{children}</AuthContext.Provider>;
}

const useAuth = () => useContext(AuthContext);

// 4. Utility Components
function LoadingSpinner() { return <div className="flex justify-center"><div className="animate-spin ..."></div></div>; }
function ProtectedRoute({ children, adminOnly }) { /* redirect if not auth */ }

// 5. Navigation
function Navigation() { /* Links: Home, Dashboard (if auth), Admin (if admin), Login/Logout */ }

// 6. Page Components
function HomePage() { /* Public welcome + logged-in summary */ }
function LoginPage() { /* Form with validation, error handling, loading state */ }
function RegisterPage() { /* Form with password confirmation */ }
function UserPage() { /* Full CRUD: list, create, edit, delete with loading/empty states */ }
function AdminPage() { /* Stats cards, data table, bulk actions, search */ }

// 7. Main App - NO BrowserRouter (main.jsx provides it)
function App() {
  return (
    <AuthProvider>
      <div className="min-h-screen bg-gray-50">
        <Navigation />
        <main className="container mx-auto px-4 py-8">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/login" element={<LoginPage />} />
            <Route path="/register" element={<RegisterPage />} />
            <Route path="/user" element={<ProtectedRoute><UserPage /></ProtectedRoute>} />
            <Route path="/admin" element={<ProtectedRoute adminOnly><AdminPage /></ProtectedRoute>} />
          </Routes>
        </main>
      </div>
    </AuthProvider>
  );
}

export default App;
```

## CRITICAL: Do NOT wrap App in BrowserRouter - main.jsx already provides it!

## AVAILABLE PACKAGES (only use these):
react, react-dom, react-router-dom, axios, react-hot-toast, @heroicons/react, date-fns, clsx, uuid

## PAGE REQUIREMENTS:
- HomePage: Welcome message, guest CTA, logged-in user stats
- LoginPage: Username/password form, loading state, error display, link to register
- RegisterPage: Username/email/password/confirm form, validation, link to login
- UserPage: CRUD interface - list items, create form, edit, delete with confirmation
- AdminPage: Stats cards, full data table, toggle status, bulk delete, search/filter

## UI REQUIREMENTS:
- Tailwind CSS for ALL styling
- Loading spinners during async operations
- Empty states with helpful messages
- Toast notifications (toast.success, toast.error)
- Responsive design

## CRITICAL RULES:
1. NO placeholders, NO TODOs, NO "..." - generate COMPLETE code
2. NO "Would you like me to continue?" - generate EVERYTHING
3. Every component must be fully implemented with real JSX
4. Generate 600-900 lines of working code
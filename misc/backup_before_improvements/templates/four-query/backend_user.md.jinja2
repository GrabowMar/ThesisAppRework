# Generate {{ name }} - Backend User Routes

{{ description }}

## Your Task

Implement the **USER-FACING** backend functionality:
- Database models in `models.py`
- User API routes in `routes/user.py`
- Business logic in `services.py` (if needed)

## Requirements

{% for req in backend_requirements %}
{{ loop.index }}. {{ req }}
{% endfor %}

{% if api_endpoints %}
## API Endpoints

{{ api_endpoints }}
{% endif %}

## Implementation Guide

**Step 1: Define Models**
Create database schema in `models.py` with:
- All required fields from requirements
- `is_active` field for soft delete
- `created_at` timestamp
- `to_dict()` method for JSON serialization

**Step 2: Implement Routes**
Create API endpoints in `routes/user.py`:
- Use `@user_bp.route('/path')` (NOT `/api/path` - prefix added automatically)
- Add input validation
- Include error handling with try/except
- Return proper status codes (200, 201, 400, 404, 500)

**Step 3: Add Business Logic (Optional)**
If you have complex operations, extract them to `services.py`

## Code Examples

### Example Model

```python
class Item(db.Model):
    __tablename__ = 'items'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat()
        }
```

### Example Route

```python
@user_bp.route('/items', methods=['GET'])
def get_items():
    try:
        items = Item.query.filter_by(is_active=True).all()
        return jsonify({
            'items': [item.to_dict() for item in items],
            'total': len(items)
        }), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

## Critical Rules

**Routing:** ⚠️
- The `user_bp` blueprint has `/api` prefix configured in `__init__.py`
- Use `@user_bp.route('/todos')` → becomes `/api/todos`
- **Never** use `@user_bp.route('/api/todos')` → causes double prefix `/api/api/todos` (404 error)

**Models:** ⚠️
- MUST include `to_dict()` method (required for JSON responses)
- MUST include `is_active` field (enables soft delete pattern)
- MUST use `datetime.utcnow` for timestamps

**Error Handling:** ⚠️
- Wrap all routes in try/except
- Always rollback on database errors: `db.session.rollback()`
- Return proper error messages with appropriate status codes

## File Structure

The scaffolding provides:
- `app.py` - DO NOT MODIFY (already configured)
- `models.py` - YOU IMPLEMENT
- `routes/user.py` - YOU IMPLEMENT
- `services.py` - YOU IMPLEMENT (optional)

## Reference: Scaffolding Context

{{ scaffolding_backend_context }}

## Output Format

Generate complete, working code:

### Models (required)
```python:models.py
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

# Your model definitions here
```

### User Routes (required)
```python:routes/user.py
from flask import jsonify, request
from routes import user_bp
from models import db, YourModel

# Your route implementations here
```

### Services (optional)
```python:services.py
from models import db, YourModel

# Complex business logic here (if needed)
```

### Extra Dependencies (optional)
```requirements
# Additional packages (if needed)
```

## Quality Checklist

Before submitting, verify:
- ✅ All models have `to_dict()` methods
- ✅ All routes use `user_bp` blueprint correctly
- ✅ All routes have error handling
- ✅ All POST/PUT routes validate input
- ✅ All database operations use soft delete (is_active filter)
- ✅ No placeholders or TODO comments
- ✅ Proper HTTP status codes used

Generate the complete implementation now.

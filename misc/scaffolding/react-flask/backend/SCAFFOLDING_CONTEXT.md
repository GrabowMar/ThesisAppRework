# Backend Scaffolding Context

## CRITICAL: Single File Architecture

**ALL backend code MUST be in ONE file: `app.py`**

The LLM will generate a complete, self-contained Flask application in app.py (400-600 lines).
This file will be COMPLETELY REPLACED by the generated code.

## File Structure
```
backend/
├── app.py           # ALL CODE GOES HERE - generated by LLM
├── requirements.txt # Base deps provided, LLM can add more
└── Dockerfile       # DO NOT MODIFY
```

## app.py Required Sections (in order)
1. **Imports** - os, logging, datetime, functools, flask, sqlalchemy, cors, bcrypt, jwt
2. **Flask app setup** - app = Flask(__name__), config, CORS
3. **Database setup** - db = SQLAlchemy(app)
4. **User model** - id, username, email, password_hash, is_admin, is_active, created_at, updated_at, to_dict()
5. **App-specific models** - All domain models with to_dict() methods
6. **Auth decorators** - token_required, admin_required
7. **Auth routes** - /api/auth/register, /api/auth/login, /api/auth/me, /api/auth/me (PUT)
8. **User routes** - /api/* CRUD endpoints
9. **Admin routes** - /api/admin/* management endpoints
10. **Health check** - GET /api/health
11. **Database initialization** - create_all() + default admin user
12. **Main entry point** - if __name__ == '__main__'

## Code Quality Requirements
- NO placeholders, NO TODOs, NO incomplete functions
- Every model MUST have to_dict() method
- All routes MUST have try/except error handling
- Proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Pagination for list endpoints (page, per_page params)
- Soft delete pattern (is_active=False)
- Input validation with descriptive error messages

## Database Configuration
```python
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:////app/data/app.db')
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')
```

## Default Admin User (create on startup)
```python
# Create default admin if not exists
admin = User.query.filter_by(username='admin').first()
if not admin:
    admin = User(username='admin', email='admin@example.com', is_admin=True)
    admin.set_password('admin123')
    db.session.add(admin)
    db.session.commit()
```

## Response Patterns
```python
return jsonify(item.to_dict()), 200       # Single item
return jsonify({'items': [...], 'total': n, 'page': 1, 'per_page': 10}), 200  # List with pagination
return jsonify(item.to_dict()), 201       # Created
return jsonify({'error': 'Error message'}), 400     # Client error
return jsonify({'error': 'Not found'}), 404         # Not found
return jsonify({'error': 'Server error'}), 500      # Server error
```

## Auth Decorator Pattern
```python
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token:
            return jsonify({'error': 'Token required'}), 401
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            user = User.query.get(data['user_id'])
            if not user or not user.is_active:
                return jsonify({'error': 'Invalid user'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except:
            return jsonify({'error': 'Invalid token'}), 401
        return f(user, *args, **kwargs)
    return decorated
```

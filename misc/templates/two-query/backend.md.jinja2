# Generate {{ name }} - Backend

{{ description }}

## Requirements
{% for req in backend_requirements %}
- {{ req }}
{% endfor %}

## API Endpoints (MUST IMPLEMENT EXACTLY)
{% if api_endpoints %}
{% for endpoint in api_endpoints %}
**{{ endpoint.method }} {{ endpoint.path }}**: {{ endpoint.description }}
{% if endpoint.response %}
  - Response: `{{ endpoint.response | tojson }}`
{% endif %}
{% endfor %}

**CRITICAL**: Frontend will call these EXACT paths. Do not use different endpoint names.
{% endif %}

## Generate Complete Flask Application

You must generate a **complete, standalone Flask application** that will replace the scaffold entirely.

## Required Components

1. **All imports** including Flask, CORS, logging, SQLAlchemy, etc.
2. **Flask app initialization**: `app = Flask(__name__)` with CORS enabled
3. **Logging configuration** using basicConfig
4. **Database instance**: `db = SQLAlchemy()`
5. **Models** (inherit `db.Model`, include `to_dict()` methods)
6. **`setup_app(app)` function** for database initialization
7. **All routes** including error handlers (404, 500)
8. **`if __name__ == '__main__'` block** that:
   - Calls `setup_app(app)` if it exists
   - Reads port from `os.environ.get('FLASK_RUN_PORT')` or `os.environ.get('PORT', 5000)`
   - Runs app with `app.run(host='0.0.0.0', port=port)`

## Critical Constraints

**Database:**
- Use `'sqlite:///app.db'` (relative path)
- In `setup_app()`: call `db.init_app(app)`, then `db.create_all()` inside `with app.app_context():`

**JSON responses:**
- Lists: `{"items": [...], "total": N, "page": 1, "per_page": 20}`
- Single: `{"id": 1, ...}` 
- Errors: `{"error": "message"}` with status 400/404/500

**Must have:**
- Full CRUD operations
- Input validation, error handling (try/except, rollback)
- Pagination (page, per_page params)
- Models use `.to_dict()` for JSON
- Health endpoint: `GET /health` returns `{"status": "healthy", "service": "backend"}`

**Output complete working Python code in a single code block.**

## Complete File Pattern

```python
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
import os
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)

db = SQLAlchemy()

class Item(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    def to_dict(self):
        return {'id': self.id, 'name': self.name}

def setup_app(app):
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    db.init_app(app)
    with app.app_context():
        db.create_all()

@app.route('/health')
def health():
    return jsonify({'status': 'healthy', 'service': 'backend'}), 200

# CRITICAL: Use EXACT endpoint paths from API Endpoints section above
# Example: @app.route('/api/todos', methods=['GET']) for todo list apps
@app.route('/api/items', methods=['GET'])
def list_items():
    items = Item.query.all()
    return jsonify({'items': [i.to_dict() for i in items], 'total': len(items)}), 200

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    logger.error(f'Error: {error}')
    return jsonify({'error': 'Internal server error'}), 500

# Initialize app at module level for Docker/WSGI compatibility
setup_app(app)

if __name__ == '__main__':
    port = int(os.environ.get('FLASK_RUN_PORT', os.environ.get('PORT', 5000)))
    app.run(host='0.0.0.0', port=port)
```


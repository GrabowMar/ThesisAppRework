# Goal: Generate a Secure & Production-Ready Flask Application - {{ name }}

This prompt directs the generation of the backend for {{ description }}.

---

### **1. Persona (Role)**

Adopt the persona of a **Security-Focused Backend Engineer**. Your expertise is in building secure, robust Flask applications with proper error handling, validation, and database management.

---

### **2. Context (Additional Information)**

* **Application Type:** {{ name }}
* **Description:** {{ description }}
* **Technology Stack:** Flask, SQLAlchemy, CORS
* **Port:** Backend will run on port 5000 (configurable)

---

### **3. Thought Generation & Planning (Internal Monologue)**

Before writing code, plan the implementation. Consider:
- Database schema design for the required features
- API endpoint structure and HTTP methods
- Input validation and error handling strategy
- Security considerations (authentication, authorization if needed)
- Data persistence and retrieval patterns

---

### **4. Directive (The Task)**

Generate the complete backend source code to implement the following functionalities:

{% for req in backend_requirements %}
{{ loop.index }}. **{{ req }}**
{% endfor %}

---

### **üìã PROCEDURAL WORKFLOW** (Follow This Sequence)

‚ö†Ô∏è **IMPORTANT**: Generate code in this exact order. Complete each step before moving to the next.

**STEP 1: Imports & Configuration** (First 30-40 lines)
```python
# Import all dependencies at the top
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import logging

# Import ANY additional libraries you need (CRITICAL: these MUST be in requirements.txt)
# Examples: lxml, bcrypt, jwt, requests, pillow, pandas, etc.

# Initialize app
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
# ... add more config
```
**‚úì Checkpoint**: Verify all imports are at the top, app is initialized
**‚úì CRITICAL**: Create a mental list of ALL packages imported - you MUST include these in requirements.txt

---

**STEP 2: Database Models** (Next 40-60 lines)
```python
# Define all database models
db = SQLAlchemy(app)

class ModelName(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    # ... add all fields based on requirements
    
    def to_dict(self):
        return {
            'id': self.id,
            # ... map all fields
        }
```
**‚úì Checkpoint**: All models defined with proper fields, relationships, and to_dict methods

---

**STEP 3: Helper Functions** (Next 30-50 lines)
```python
# Add utility functions
def validate_input(data, required_fields):
    """Validate required fields are present"""
    missing = [field for field in required_fields if field not in data]
    if missing:
        return False, f"Missing required fields: {', '.join(missing)}"
    return True, None

def handle_db_error(error):
    """Centralized database error handling"""
    logger.error(f"Database error: {str(error)}")
    return jsonify({'error': 'Database operation failed'}), 500
```
**‚úì Checkpoint**: Helper functions for validation, formatting, error handling

---

**STEP 4: Core Endpoints** (Next 150-250 lines)
```python
# Implement each endpoint one at a time

@app.route('/api/resource', methods=['GET'])
def get_resources():
    """Get all resources"""
    try:
        resources = ModelName.query.all()
        return jsonify([r.to_dict() for r in resources]), 200
    except Exception as e:
        return handle_db_error(e)

@app.route('/api/resource', methods=['POST'])
def create_resource():
    """Create new resource"""
    data = request.get_json()
    
    # Validate input
    valid, error_msg = validate_input(data, ['required_field1', 'required_field2'])
    if not valid:
        return jsonify({'error': error_msg}), 400
    
    try:
        new_resource = ModelName(**data)
        db.session.add(new_resource)
        db.session.commit()
        return jsonify(new_resource.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return handle_db_error(e)

# Repeat for each endpoint based on requirements
```
**‚úì Checkpoint**: Each endpoint has error handling and returns proper JSON

---

**STEP 5: Database Initialization & Main** (Final 30-40 lines)
```python
# Initialize database and run app
if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        logger.info("Database initialized successfully")
        
        # Optionally add sample data for testing
        # if ModelName.query.count() == 0:
        #     sample = ModelName(field='value')
        #     db.session.add(sample)
        #     db.session.commit()
    
    logger.info("Starting Flask application on port 5000...")
    app.run(host='0.0.0.0', port=5000, debug=True)
```
**‚úì Checkpoint**: App runs without errors, database initializes

---

### **üéØ VALIDATION CHECKLIST** (Complete Before Submitting)

**Code Structure:**
- [ ] All imports at top (stdlib ‚Üí third-party ‚Üí local)
- [ ] Flask app initialized with all config
- [ ] Database models defined with all fields
- [ ] All endpoints implemented (not just stubs)
- [ ] Proper use of HTTP methods (GET, POST, PUT, DELETE)

**Error Handling:**
- [ ] Try/except blocks on all database operations
- [ ] Proper HTTP status codes (200, 201, 400, 404, 500)
- [ ] Validation for all input data
- [ ] Logging for errors and important events
- [ ] Rollback on failed transactions

**Functionality:**
- [ ] Each endpoint returns proper JSON format
- [ ] Database operations work correctly (CRUD)
- [ ] Relationships between models properly defined
- [ ] Edge cases handled (empty data, invalid IDs, duplicates)
- [ ] CORS configured for frontend communication

**Code Quality:**
- [ ] No TODO or placeholder comments
- [ ] No hardcoded values (use config/env where appropriate)
- [ ] Clear variable/function names
- [ ] Docstrings for all functions and endpoints
- [ ] Consistent code style and formatting

**Dependencies (CRITICAL - App Will Crash If Wrong):**
- [ ] Every import in app.py has a corresponding entry in requirements.txt
- [ ] All third-party packages have version numbers (e.g., lxml==5.1.0)
- [ ] Standard library modules (os, sys, datetime, etc.) are NOT in requirements.txt
- [ ] Flask, Flask-CORS, Flask-SQLAlchemy are included
- [ ] If you use lxml, bcrypt, jwt, requests, pillow, pandas, etc. - they MUST be listed

---

### **5. Output Specification (Answer Engineering)**

#### **Deliverables**

Generate the following two files. Do **not** generate a `Dockerfile`.

1. **`app.py`**: Complete Flask application implementing all requirements
2. **`requirements.txt`**: Python dependency list

#### **Code Quality & Technical Mandates**

* **`app.py` Structure (Expand from this skeleton):**

```python
{{ scaffolding_app_py }}
```

* **Required Libraries:** Flask, Flask-CORS, Flask-SQLAlchemy (add others as needed for requirements)
* **Database:** Use SQLite with SQLAlchemy ORM
* **Security:** Implement proper input validation, error handling, and sanitization
* **Port Configuration:** Application must run on host `0.0.0.0` and port `5000`

#### **`requirements.txt` Base:**

```
{{ scaffolding_requirements_txt }}
```

‚ö†Ô∏è **CRITICAL DEPENDENCY INSTRUCTIONS:**

**YOU MUST analyze your app.py code and add EVERY third-party package you imported.**

**Common packages that MUST be added if you use them:**
- `lxml==5.1.0` - if you import lxml for XML/HTML processing
- `bcrypt==4.1.2` - if you import bcrypt for password hashing
- `PyJWT==2.8.0` - if you import jwt for tokens
- `requests==2.31.0` - if you import requests for HTTP calls
- `Pillow==10.2.0` - if you import PIL for image processing
- `pandas==2.2.0` - if you import pandas for data analysis
- `python-dotenv==1.0.0` - if you import dotenv for env vars
- `werkzeug==3.0.1` - usually included with Flask, but add if you import werkzeug directly
- `SQLAlchemy==2.0.25` - usually included with Flask-SQLAlchemy, but add if importing directly
- `cryptography==42.0.0` - if you import cryptography
- `celery==5.3.4` - if you import celery for async tasks
- `redis==5.0.1` - if you import redis

**Process for generating requirements.txt:**
1. Review EVERY import statement in your app.py
2. Identify which imports are third-party packages (not Python stdlib)
3. Add each third-party package to requirements.txt with a version number
4. Include the base packages: Flask==3.0.0, Flask-CORS==4.0.0, Flask-SQLAlchemy==3.1.1
5. Double-check you didn't miss any package

**Example - if app.py contains:**
```python
from flask import Flask  # ‚Üí Flask==3.0.0
from flask_cors import CORS  # ‚Üí Flask-CORS==4.0.0
from lxml import etree  # ‚Üí lxml==5.1.0
import requests  # ‚Üí requests==2.31.0
import datetime  # ‚Üí STDLIB - don't add
```

**Then requirements.txt should be:**
```
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SQLAlchemy==3.1.1
lxml==5.1.0
requests==2.31.0
```

---

#### **Final Review (Self-Correction)**

After generating the code, perform a final internal review to ensure:
- All requirements are fully implemented
- Endpoints handle errors gracefully
- Database schema matches requirements
- Code is production-ready and follows best practices
- No placeholder or incomplete implementations

You may now begin.
